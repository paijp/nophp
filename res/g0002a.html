<FORM method=POST>
Welcome `login__:loginrecord`!
<INPUT type=submit name=":logout" value="logout">
<A href="g9999.html">index</A>
</FORM>
<FORM method=POST>
<INPUT type=text name=":reportbody" size=60>
<INPUT type=submit value="send report">
</FORM>
<UL>
	<LI>No change from <A href="g0002.html">tables.php before</A>.
</UL>
<TABLE border width="96%">
<TR><TH>g0002a.html
<TH>HTML sent to the browser
<TH>Display on the browser(can be operated)
<TR><TD width="33%">&lt;FORM method=POST&gt;<br />
search keyword:<br />
&lt;INPUT type=text name=&quot;0body&quot;&gt;<br />
&lt;INPUT type=submit value=&quot;searching for&quot;&gt;<br />
&lt;!--{if `:bq`0body__:p:isnull:isnull`:bq`--&gt;<br />
&lt;!--{selectrows from message2 where 1 order by id desc `:bq`0body__:p__body__:sqllike`:bq` --&gt;<br />
&lt;HR&gt;<br />
&lt;SPAN style=&quot;color:#a0a0a0;&quot;&gt;#`:bq`id__:r`:bq`&lt;/SPAN&gt;<br />
&lt;B&gt;`:bq`owner__:r__login__login__:t_id`:bq`&lt;/B&gt;<br />
&lt;SPAN style=&quot;color:#a0a0a0;&quot;&gt;`:bq`created__:r__y/m/d H:i:s__:todate`:bq`&lt;/SPAN&gt;<br />
&lt;PRE&gt;`:bq`body__:r`:bq`&lt;/PRE&gt;<br />
&lt;!--}--&gt;<br />
&lt;!--}--&gt;<br />
&lt;/FORM&gt;<br />
<br />

<TD width="34%"><!--{htmlsrc--><FORM method=POST>
search keyword:
<INPUT type=text name="0body">
<INPUT type=submit value="searching for">
<!--{if `0body__:p:isnull:isnull`-->
<!--{selectrows from message2 where 1 order by id desc `0body__:p__body__:sqllike` -->
<HR>
<SPAN style="color:#a0a0a0;">#`id__:r`</SPAN>
<B>`owner__:r__login__login__:t_id`</B>
<SPAN style="color:#a0a0a0;">`created__:r__y/m/d H:i:s__:todate`</SPAN>
<PRE>`body__:r`</PRE>
<!--}-->
<!--}-->
</FORM>

<!--}-->
<TD width="33%"><FORM method=POST>
search keyword:
<INPUT type=text name="0body">
<INPUT type=submit value="searching for">
<!--{if `0body__:p:isnull:isnull`-->
<!--{selectrows from message2 where 1 order by id desc `0body__:p__body__:sqllike` -->
<HR>
<SPAN style="color:#a0a0a0;">#`id__:r`</SPAN>
<B>`owner__:r__login__login__:t_id`</B>
<SPAN style="color:#a0a0a0;">`created__:r__y/m/d H:i:s__:todate`</SPAN>
<PRE>`body__:r`</PRE>
<!--}-->
<!--}-->
</FORM>


</TABLE>

<UL>
	<LI>&lt;!--{selectrows&quot; with &quot;where&quot; to perform the search.
</UL>


<UL>
	<LI>First, you can use &quot;&lt;!--{if&quot; to not display results when no search keywords are entered.
	<LI>The &quot;0body__:p&quot; part takes out the POST parameter. Note that field names that begin with a number, such as &quot;&lt;!--{tableid&quot;, etc., will not be written to the database.
	<LI>The &quot;:isnull&quot; returns &quot;1&quot; if the string is empty, otherwise it returns an empty string.
	<LI>By repeating the two, only if &quot;0body__:p&quot; is non-empty, &quot;&lt;!--{if&quot; is processed.
	<LI>If it's hard to understand, use else, and then &quot;&lt;!--{if `:bq`0body__:p:isnull`:bq`--&gt;&lt;!--}{else--&gt;&quot; will give the same result.
</UL>


<UL>
	<LI>The &quot;`:bq`0body__:p__body__:sqllike`:bq`&quot; part will eventually embed &quot;body like &quot;%keyword%&quot; and&quot; immediately after the where. SQL escaping is also performed.
	<LI>Since there is a 1 immediately after, the search can be done by arranging the criteria in this way.
</UL>


<UL>
	<LI>The following is a list of the &quot;&lt;!--{tablegrid&quot; parameter section and &quot;&lt;!--}--&quot; up to and including &quot;&lt;!--{selectrows&quot; parameter section.
	<LI>sqlisnull takes one string from the stack, considers it a field name, and adds &quot;and field name is null&quot; to the corresponding SQL statement.
	<LI>sqlisnotnull takes one string from the stack, considers it a field name, and adds &quot;and field name is not null&quot; to the corresponding SQL statement.
	<LI>sqlisempty takes one string from the stack, considers it a field name, and adds &quot;and (field name is null or field name = &quot;&quot;)&quot; to the corresponding SQL statement.
	<LI>sqlisnotempty takes one string from the stack, considers it a field name, and adds &quot;and field name is not null and field name &lt;&gt; &quot;&quot; to the corresponding SQL statement.
	<LI>sqllike takes two strings from the stack, considers each to be a search string and a field name, and adds &quot;and field name like &quot;%search string%&quot;&quot; to the corresponding SQL statement.
	<LI>sqllike2 takes three strings from the stack, considers them as search string, field name 1, and field name 2, respectively, and adds &quot;and (field name 1 like &quot;%search string%&quot; or field name 2 like &quot;%search string%&quot;)&quot; to the corresponding SQL statement.
	<LI>sqllike3 takes four strings from the stack, considers each as a search string, field name 1, field name 2, and field name 3, and adds &quot;and (field name 1 like &quot;%Search String%&quot; or field name 2 like &quot;%Search String%&quot; or field Field name 3 like &quot;%Search String %&quot;)&quot; is added.
	<LI>sqllike4 takes five strings from the stack, considers each as a search string, field name 1, field name 2, field name 3, and field name 4, and adds &quot;and (field name 1 like &quot;%Search String%&quot; or field name 2 like &quot;%Search String %&quot; or field name 3 like &quot;%search string%&quot; or field name 4 like &quot;%search string&quot;)&quot; is added.
	<LI>sqlnotlike takes two strings from the stack, considers each to be a search string and a field name, and adds &quot;and field name not like &quot;%search string%&quot;&quot; to the corresponding SQL statement.
	<LI>sqleq takes two strings from the stack, considers each to be a string and a field name, and adds &quot;and &quot;string&quot; = field name&quot; to the corresponding SQL statement.
	<LI>sqlne takes two strings from the stack, considers each to be a string and a field name, and adds &quot;and &quot;string&quot; &lt;&gt; field name&quot; to the corresponding SQL statement.
	<LI>sqllt takes two strings from the stack, considers each to be a string and a field name, and adds &quot;and &quot;string&quot; &lt; field name&quot; to the corresponding SQL statement.
	<LI>sqlle takes two strings from the stack, considers each to be a string and a field name, and adds &quot;and &quot;string&quot; &lt;= field name&quot; to the corresponding SQL statement.
	<LI>sqlgt takes two strings from the stack, considers each to be a string and a field name, and adds &quot;and &quot;string&quot; &gt; field name&quot; to the corresponding SQL statement.
	<LI>sqlge takes two strings from the stack, considers each to be a string and a field name, and adds &quot;and &quot;string&quot; &gt;= field name&quot; to the corresponding SQL statement.
</UL>


<HR>
